install.packages("writexl")   # solo la primera vez
library(writexl)
write_xlsx(as.data.frame(W, stringsAsFactors = FALSE),
path = "Coeficientes_WILI.xlsx")
clean_names <- function(x) gsub("\\s*-\\s*", "-", trimws(x))
extract_id  <- function(x) as.integer(sub(".*-(\\d+)$", "\\1", x))
rownames(Matriz_WILIAM) <- clean_names(rownames(Matriz_WILIAM))
colnames(Matriz_WILIAM) <- clean_names(colnames(Matriz_WILIAM))
write_xlsx(as.data.frame(W, stringsAsFactors = FALSE),
path = "Coeficientes_WILI.xlsx")
write_xlsx(as.data.frame(W, stringsAsFactors = FALSE),
path = "Coeficientes_WILI.xlsx")
# ===== 0) LECTURA DE TU EXCEL BASE =====
# install.packages("openxlsx")
library(openxlsx)
# Cambia la ruta si no estÃ¡ en el working dir
ruta_base <- "W.xlsx"
hoja_base <- 1  # o "NombreDeHoja"
Matriz_WILIAM <- read.xlsx(ruta_base, sheet = hoja_base, rowNames = TRUE)
Matriz_WILIAM <- data.matrix(Matriz_WILIAM)
# Normaliza mÃ­nimamente: mayÃºsculas, sin espacios alrededor del guion
canon <- function(v){
v <- trimws(v)
v <- gsub("\\s*-\\s*", "-", v)
toupper(v)
}
rownames(Matriz_WILIAM) <- canon(rownames(Matriz_WILIAM))
colnames(Matriz_WILIAM) <- canon(colnames(Matriz_WILIAM))
# Alinea columnas al orden de las filas (o intersecta si difieren)
if (setequal(rownames(Matriz_WILIAM), colnames(Matriz_WILIAM))) {
Matriz_WILIAM <- Matriz_WILIAM[rownames(Matriz_WILIAM), rownames(Matriz_WILIAM), drop=FALSE]
} else {
faltan_en_cols <- setdiff(rownames(Matriz_WILIAM), colnames(Matriz_WILIAM))
faltan_en_rows <- setdiff(colnames(Matriz_WILIAM), rownames(Matriz_WILIAM))
cat("âš  Faltan en columnas:", length(faltan_en_cols), "\n")
cat("âš  Faltan en filas   :", length(faltan_en_rows), "\n")
comunes <- intersect(rownames(Matriz_WILIAM), colnames(Matriz_WILIAM))
stopifnot(length(comunes) > 0)
Matriz_WILIAM <- Matriz_WILIAM[comunes, comunes, drop=FALSE]
}
# ===== 0) LECTURA DE TU EXCEL BASE =====
# install.packages("openxlsx")
library(openxlsx)
# Cambia la ruta si no estÃ¡ en el working dir
ruta_base <- "W.xlsx"
hoja_base <- 1  # o "NombreDeHoja"
Matriz_WILIAM <- read.xlsx(ruta_base, sheet = hoja_base, rowNames = TRUE)
Matriz_WILIAM <- data.matrix(Matriz_WILIAM)
# Normaliza mÃ­nimamente: mayÃºsculas, sin espacios alrededor del guion
canon <- function(v){
v <- trimws(v)
v <- gsub("\\s*-\\s*", "-", v)
toupper(v)
}
rownames(Matriz_WILIAM) <- canon(rownames(Matriz_WILIAM))
colnames(Matriz_WILIAM) <- canon(colnames(Matriz_WILIAM))
if (setequal(rownames(Matriz_WILIAM), colnames(Matriz_WILIAM))) {
Matriz_WILIAM <- Matriz_WILIAM[rownames(Matriz_WILIAM), rownames(Matriz_WILIAM), drop=FALSE]
} else {
faltan_en_cols <- setdiff(rownames(Matriz_WILIAM), colnames(Matriz_WILIAM))
faltan_en_rows <- setdiff(colnames(Matriz_WILIAM), rownames(Matriz_WILIAM))
cat("âš  Faltan en columnas:", length(faltan_en_cols), "\n")
cat("âš  Faltan en filas   :", length(faltan_en_rows), "\n")
comunes <- intersect(rownames(Matriz_WILIAM), colnames(Matriz_WILIAM))
stopifnot(length(comunes) > 0)
Matriz_WILIAM <- Matriz_WILIAM[comunes, comunes, drop=FALSE]
}
View(Matriz_WILIAM)
# Cambia la ruta si no estÃ¡ en el working dir
ruta_base <- "W.xlsx"
hoja_base <- 1  # o "NombreDeHoja"
Matriz_WILIAM <- read.xlsx(ruta_base, sheet = hoja_base, rowNames = TRUE)
Matriz_WILIAM <- data.matrix(Matriz_WILIAM)
clean_names <- function(x) gsub("\\s*-\\s*", "-", trimws(x))
extract_id  <- function(x) as.integer(sub(".*-(\\d+)$", "\\1", x))
rownames(Matriz_WILIAM) <- clean_names(rownames(Matriz_WILIAM))
colnames(Matriz_WILIAM) <- clean_names(colnames(Matriz_WILIAM))
codes <- rownames(Matriz_WILIAM)
ids   <- extract_id(codes)
n     <- length(ids)
B_groups <- list(
B1 = 9:17,
B2 = 47:49,
B3 = 50:51,
B4 = 58:62,
B5 = c(6, 21)  # NUEVO: 6 y 21 juntos como un subgrupo
)
# Conjunto de posiciones (Ã­ndices 1..n) que pertenecen a cualquier B*
B_all <- sort(which(ids %in% unlist(B_groups, use.names = FALSE)))
C2    <- B_all                       # columnas/fila subdivididas
A     <- sort(setdiff(seq_len(n), B_all))  # no subdivididos
# Helpers para obtener Ã­ndices de grupo o nombre de grupo
get_grp_indices <- function(i_index) {
id_i <- ids[i_index]
for (nm in names(B_groups)) if (id_i %in% B_groups[[nm]]) {
return(which(ids %in% B_groups[[nm]]))
}
return(NULL) # estÃ¡ en A
}
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 1) ConstrucciÃ³n de la matriz de coeficientes W
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
W <- matrix(NA, n, n, dimnames = list(codes, codes))
for (i in seq_len(n)) {
inA_i <- i %in% A
grp_i <- get_grp_indices(i)      # NULL si fila estÃ¡ en A
for (j in seq_len(n)) {
xij    <- Matriz_WILIAM[i, j]
inA_j  <- j %in% A
inC2_j <- j %in% C2
grp_j  <- get_grp_indices(j)   # NULL si col estÃ¡ en A
# 1.1 AÃ—A â†’ 1
if (inA_i && inA_j) {
W[i,j] <- 1
# 1.2 AÃ—C2 â†’ normalizaciÃ³n por suma de fila i sobre C2
} else if (inA_i && inC2_j) {
denom <- sum(Matriz_WILIAM[i, C2])
W[i,j] <- if (denom == 0) 0 else xij/denom
# 1.3 BxÃ—A â†’ normalizaciÃ³n por suma de columna j dentro del grupo de i
} else if (!is.null(grp_i) && inA_j) {
denom <- sum(Matriz_WILIAM[grp_i, j])
W[i,j] <- if (denom == 0) 0 else xij/denom
# 1.4 BxÃ—By â†’ normalizaciÃ³n por suma total del bloque grp_i Ã— grp_j
} else if (!is.null(grp_i) && !is.null(grp_j)) {
denom <- sum(Matriz_WILIAM[grp_i, grp_j])
W[i,j] <- if (denom == 0) 0 else xij/denom
# 1.5 resto â†’ NA
} else {
W[i,j] <- NA
}
}
}
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 2) CHEQUEOS de normalizaciÃ³n (dinÃ¡micos)
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
tol <- 1e-8
all_ok <- TRUE
# 2.a) AÃ—A == 1
if (!all(W[A, A, drop=FALSE] == 1)) {
cat("âœ– Error en AÃ—A (identidad)\n"); all_ok <- FALSE
} else cat("âœ” AÃ—A OK\n")
# 2.b) AÃ—C2: cada fila i en A (con flujo a C2) suma 1 sobre C2
rs_AC2 <- sapply(A, function(i) {
d <- sum(Matriz_WILIAM[i, C2])
if (d == 0) return(NA_real_)
sum(W[i, C2], na.rm=TRUE)
})
for (k in which(!is.na(rs_AC2))) {
if (abs(rs_AC2[k] - 1) > tol) {
cat(sprintf("âœ– AÃ—C2 fila %s suma=%.6f\n", codes[A[k]], rs_AC2[k])); all_ok <- FALSE
}
}
cat("âœ” AÃ—C2 comprobado\n")
# 2.c) BxÃ—A: para cada subgrupo, columnas j en A suman 1
for (nm in names(B_groups)) {
grp_pos <- which(ids %in% B_groups[[nm]])
for (j in A) {
d <- sum(Matriz_WILIAM[grp_pos, j])
if (d == 0) next
s <- sum(W[grp_pos, j], na.rm=TRUE)
if (abs(s-1) > tol) {
cat(sprintf("âœ– %sÃ—A col %s suma=%.6f\n", nm, codes[j], s)); all_ok <- FALSE
}
}
}
cat("âœ” BxÃ—A comprobado\n")
# 2.d) BxÃ—By: cada bloque suma 1
for (g1 in names(B_groups)) {
grp1_pos <- which(ids %in% B_groups[[g1]])
for (g2 in names(B_groups)) {
grp2_pos <- which(ids %in% B_groups[[g2]])
total <- sum(W[grp1_pos, grp2_pos], na.rm=TRUE)
if (abs(total - 1) > tol) {
cat(sprintf("âœ– %sÃ—%s suma bloque=%.6f\n", g1, g2, total)); all_ok <- FALSE
}
}
}
cat("âœ” BxÃ—By comprobado\n")
if (all_ok) {cat("\nðŸŽ‰ Todos los checks PASAN (tol =", tol, ")\n")
}else { cat("\nâš ï¸ Algunos checks FALLARON. Revisa los mensajes.\n")}
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 3) ExportaciÃ³n
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
write_xlsx(as.data.frame(W, stringsAsFactors = FALSE),
path = "Coeficientes_WILI.xlsx")
# --- NÃºcleo: chequea un texto plano ya extraÃ­do ---
check_wiliam_packet <- function(text) {
# NormalizaciÃ³n simple
norm <- function(x) {
x |>
stringr::str_replace_all("\\s+", " ") |>
stringr::str_trim()
}
txt <- norm(text)
checks <- tibble::tibble(
item = character(), pattern = character(), ok = logical(), note = character()
)
add_check <- function(item, pattern, note = "") {
ok <- str_detect(txt, regex(pattern, ignore_case = TRUE))
tibble::tibble(item = item, pattern = pattern, ok = ok, note = note)
}
# 1) Secciones obligatorias
sec_patterns <- list(
c("Section: Introduction",          "Introduction"),
c("Section: Results â€” WILIAM",      "Results\\s*[â€”-]\\s*WILIAM"),
c("Section: Discussion â€” WILIAM",   "Discussion\\s*[â€”-]\\s*WILIAM"),
c("Section: Conclusions â€” WILIAM",  "Conclusions\\s*[â€”-]\\s*WILIAM")
)
# 2) Tabla 3 (solo fila WILIAM)
tab3_patterns <- list(
c("Table 3 label",                  "Table\\s*3"),
c("Table 3: model WILIAM",          "\\bWILIAM\\b"),
c("Table 3: Institutional modules", "Institutional modules"),
c("Table 3: LOCOMOTION-H2020, 2024","LOCOMOTION-?H2020,?\\s*2024")
)
# 3) Tabla 7/8 (resumen heterogeneidades) â€” filas de WILIAM
tab7_patterns <- list(
c("Table 7/8 label",                      "Table\\s*7|Table\\s*8"),
c("WILIAM Age row",                        "WILIAM.*Age.*Demographic cohorts"),
c("WILIAM Gender row",                     "WILIAM.*Gender.*Demographic cohorts"),
c("WILIAM Education row",                  "WILIAM.*Education.*Work\\s*Skills.*Education Module"),
c("WILIAM Income row",                     "WILIAM.*Income.*Household Disaggregation.*Economic Agents"),
c("WILIAM Inequality in scenarios = No",   "WILIAM.*\\bNo\\b")
)
# 4) Citas en texto (abreviaturas)
cite_patterns <- list(
c("In-text: (Blas Sanz et al., 2021)",        "\\(\\s*Blas\\s+Sanz\\s+et\\s+al\\.,\\s*2021\\s*\\)"),
c("In-text: (LOCOMOTION-H2020, 2024)",        "\\(\\s*LOCOMOTION-?H2020,\\s*2024\\s*\\)"),
c("In-text: (CapellÃ¡n-PÃ©rez et al., 2020)",   "\\(\\s*Capell[aÃ¡]n-?P[eÃ©]rez\\s+et\\s+al\\.,\\s*2020\\s*\\)")
)
# 5) Referencias completas en la bibliografÃ­a
ref_patterns <- list(
c("Ref: Blas Sanz et al. (2021)",
"Blas\\s+Sanz.*2021.*Interim\\s+synthesis\\s+of\\s+the\\s+model.*LOCOMOTION",
"Debe figurar la referencia completa del deliverable D9.2"),
c("Ref: LOCOMOTION-H2020 (2024)",
"LOCOMOTION-?h2020.*2024.*GitHub.*WILIAM_model_VENSIM.*The-Economy-module",
"Debe figurar el enlace/documentaciÃ³n tÃ©cnica"),
c("Ref: CapellÃ¡n-PÃ©rez et al. (2020)",
"Capell[aÃ¡]n-?P[eÃ©]rez.*2020.*MEDEAS.*Energy\\s*&\\s*Environmental\\s*Science",
"Base metodolÃ³gica (MEDEAS)")
)
# 6) Frases clave del bloque Results â€” WILIAM (para asegurar contenido)
key_results <- list(
c("Key: WILIAM spelled out",        "WithIn\\s+Limits\\s+Integrated\\s+Assessment\\s+Model"),
c("Key: household disaggregation",  "income\\s+quintile|quintiles|rural\\s*\\/\\s*urban|urban\\s+and\\s+rural"),
c("Key: consumption propensities",  "propensit(?:y|ies)\\s+to\\s+consume"),
c("Key: policy levers",             "income\\s+tax|social\\s+security\\s+tax|subsidies|transfers"),
c("Key: government redistribution", "government.*collects.*taxation.*redistribut"),
c("Key: education module",          "education\\s+module.*Human\\s+Development\\s+Index|HDI")
)
# Acumular checks
for (p in sec_patterns)   checks <- bind_rows(checks, add_check(p[1], p[2]))
for (p in tab3_patterns)  checks <- bind_rows(checks, add_check(p[1], p[2]))
for (p in tab7_patterns)  checks <- bind_rows(checks, add_check(p[1], p[2]))
for (p in cite_patterns)  checks <- bind_rows(checks, add_check(p[1], p[2]))
for (p in key_results)    checks <- bind_rows(checks, add_check(p[1], p[2]))
for (p in ref_patterns) {
checks <- bind_rows(checks, add_check(p[1], p[2], note = p[3]))
}
# Resumen
list(
pass = all(checks$ok),
summary = checks |> mutate(status = if_else(ok, "OK", "MISSING")) |>
select(item, status, note, pattern)
)
}
# --- Wrapper: lee un DOCX y llama al chequeo ---
check_wiliam_packet_docx <- function(docx_path) {
doc <- read_docx(docx_path)
dd  <- docx_summary(doc)
# concatenar todo el texto extraÃ­do (pÃ¡rrafos, tablas, encabezados)
text <- paste(dd$text, collapse = "\n")
check_wiliam_packet(text)
}
## ----------------
## EJEMPLOS DE USO
## ----------------
# 1) Si lo tienes como .docx (p.ej., WILIAM_Extracts.docx):
# res <- check_wiliam_packet_docx("WILIAM_Extracts.docx")
# res$pass        # TRUE/FALSE
# res$summary     # tabla con cada check
# 2) Si prefieres pasarle un string de texto:
# txt <- "Pega aquÃ­ todo el contenido del documento..."
# res <- check_wiliam_packet(txt)
# View(res$summary)
View(B_groups)
View(Matriz_WILIAM)
B_groups <- list(
B1 = 9:17,
B2 = 47:49,
B3 = 50:51,
B4 = 58:62,
B5 = c(6, 21)  # NUEVO: 6 y 21 juntos como un subgrupo
)
# Conjunto de posiciones (Ã­ndices 1..n) que pertenecen a cualquier B*
B_all <- sort(which(ids %in% unlist(B_groups, use.names = FALSE)))
ruta_base <- "W.xlsx"
hoja_base <- 1  # o "NombreDeHoja"
Matriz_WILIAM <- read.xlsx(ruta_base, sheet = hoja_base, rowNames = TRUE)
Matriz_WILIAM <- data.matrix(Matriz_WILIAM)
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 0) Helpers y definiciÃ³n de grupos (6 y 21 juntos)
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
clean_names <- function(x) gsub("\\s*-\\s*", "-", trimws(x))
extract_id  <- function(x) as.integer(sub(".*-(\\d+)$", "\\1", x))
rownames(Matriz_WILIAM) <- clean_names(rownames(Matriz_WILIAM))
colnames(Matriz_WILIAM) <- clean_names(colnames(Matriz_WILIAM))
codes <- rownames(Matriz_WILIAM)
ids   <- extract_id(codes)
n     <- length(ids)
# Subgrupos de sectores subdivididos (ahora con B5 = {6,21})
B_groups <- list(
B1 = 9:17,
B2 = 47:49,
B3 = 50:51,
B4 = 58:62,
B5 = c(6, 21)  # NUEVO: 6 y 21 juntos como un subgrupo
)
# Conjunto de posiciones (Ã­ndices 1..n) que pertenecen a cualquier B*
B_all <- sort(which(ids %in% unlist(B_groups, use.names = FALSE)))
C2    <- B_all                       # columnas/fila subdivididas
A     <- sort(setdiff(seq_len(n), B_all))  # no subdivididos
# Helpers para obtener Ã­ndices de grupo o nombre de grupo
get_grp_indices <- function(i_index) {
id_i <- ids[i_index]
for (nm in names(B_groups)) if (id_i %in% B_groups[[nm]]) {
return(which(ids %in% B_groups[[nm]]))
}
return(NULL) # estÃ¡ en A
}
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 1) ConstrucciÃ³n de la matriz de coeficientes W
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
W <- matrix(NA, n, n, dimnames = list(codes, codes))
for (i in seq_len(n)) {
inA_i <- i %in% A
grp_i <- get_grp_indices(i)      # NULL si fila estÃ¡ en A
for (j in seq_len(n)) {
xij    <- Matriz_WILIAM[i, j]
inA_j  <- j %in% A
inC2_j <- j %in% C2
grp_j  <- get_grp_indices(j)   # NULL si col estÃ¡ en A
# 1.1 AÃ—A â†’ 1
if (inA_i && inA_j) {
W[i,j] <- 1
# 1.2 AÃ—C2 â†’ normalizaciÃ³n por suma de fila i sobre C2
} else if (inA_i && inC2_j) {
denom <- sum(Matriz_WILIAM[i, C2])
W[i,j] <- if (denom == 0) 0 else xij/denom
# 1.3 BxÃ—A â†’ normalizaciÃ³n por suma de columna j dentro del grupo de i
} else if (!is.null(grp_i) && inA_j) {
denom <- sum(Matriz_WILIAM[grp_i, j])
W[i,j] <- if (denom == 0) 0 else xij/denom
# 1.4 BxÃ—By â†’ normalizaciÃ³n por suma total del bloque grp_i Ã— grp_j
} else if (!is.null(grp_i) && !is.null(grp_j)) {
denom <- sum(Matriz_WILIAM[grp_i, grp_j])
W[i,j] <- if (denom == 0) 0 else xij/denom
# 1.5 resto â†’ NA
} else {
W[i,j] <- NA
}
}
}
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 2) CHEQUEOS de normalizaciÃ³n (dinÃ¡micos)
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
tol <- 1e-8
all_ok <- TRUE
# 2.a) AÃ—A == 1
if (!all(W[A, A, drop=FALSE] == 1)) {
cat("âœ– Error en AÃ—A (identidad)\n"); all_ok <- FALSE
} else cat("âœ” AÃ—A OK\n")
# 2.b) AÃ—C2: cada fila i en A (con flujo a C2) suma 1 sobre C2
rs_AC2 <- sapply(A, function(i) {
d <- sum(Matriz_WILIAM[i, C2])
if (d == 0) return(NA_real_)
sum(W[i, C2], na.rm=TRUE)
})
for (k in which(!is.na(rs_AC2))) {
if (abs(rs_AC2[k] - 1) > tol) {
cat(sprintf("âœ– AÃ—C2 fila %s suma=%.6f\n", codes[A[k]], rs_AC2[k])); all_ok <- FALSE
}
}
cat("âœ” AÃ—C2 comprobado\n")
# 2.c) BxÃ—A: para cada subgrupo, columnas j en A suman 1
for (nm in names(B_groups)) {
grp_pos <- which(ids %in% B_groups[[nm]])
for (j in A) {
d <- sum(Matriz_WILIAM[grp_pos, j])
if (d == 0) next
s <- sum(W[grp_pos, j], na.rm=TRUE)
if (abs(s-1) > tol) {
cat(sprintf("âœ– %sÃ—A col %s suma=%.6f\n", nm, codes[j], s)); all_ok <- FALSE
}
}
}
cat("âœ” BxÃ—A comprobado\n")
# 2.d) BxÃ—By: cada bloque suma 1
for (g1 in names(B_groups)) {
grp1_pos <- which(ids %in% B_groups[[g1]])
for (g2 in names(B_groups)) {
grp2_pos <- which(ids %in% B_groups[[g2]])
total <- sum(W[grp1_pos, grp2_pos], na.rm=TRUE)
if (abs(total - 1) > tol) {
cat(sprintf("âœ– %sÃ—%s suma bloque=%.6f\n", g1, g2, total)); all_ok <- FALSE
}
}
}
cat("âœ” BxÃ—By comprobado\n")
if (all_ok) {cat("\nðŸŽ‰ Todos los checks PASAN (tol =", tol, ")\n")
}else { cat("\nâš ï¸ Algunos checks FALLARON. Revisa los mensajes.\n")}
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# 3) ExportaciÃ³n
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
write_xlsx(as.data.frame(W, stringsAsFactors = FALSE),
path = "Coeficientes_WILI.xlsx")
