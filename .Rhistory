mat <- as.matrix(df[, -1, drop = FALSE])
storage.mode(mat) <- "double"
colnames(mat) <- clean_names(colnames(df)[-1])
rownames(mat) <- rn
} else {
# Intento directo (cabeceras ya traen colnames; sin rownames explícitos → error)
mat <- as.matrix(df)
storage.mode(mat) <- "double"
if (is.null(rownames(mat))) stop("El Excel debe tener la 1ª columna con los nombres de fila tipo 'PAIS-<id>'.")
rownames(mat) <- clean_names(rownames(mat))
colnames(mat) <- clean_names(colnames(mat))
}
mat
}
# ---------------- Definición de grupos especiales ----------------
# 5 subgrupos (disjuntos):
#  - G6_21  : {6,21}
#  - G9_17  : 9:17
#  - G47_49 : 47:49
#  - G50_51 : 50:51
#  - G58_62 : 58:62
SPECIAL_GROUPS <- list(
G6_21  = c(6, 21),
G9_17  = 9:17,
G47_49 = 47:49,
G50_51 = 50:51,
G58_62 = 58:62
)
ALL_SPECIAL_IDS <- sort(unique(unlist(SPECIAL_GROUPS)))
# ---------------- Normalización por bloques país–país ----------------
normalize_W_global <- function(W){
# Limpia nombres e identifica países e ids
rn <- clean_names(rownames(W)); cn <- clean_names(colnames(W))
if (anyNA(rn) || anyNA(cn)) stop("W debe tener nombres de fila/columna tipo 'PAIS-<id>'.")
id_r <- extract_id(rn); id_c <- extract_id(cn)
if (anyNA(id_r) || anyNA(id_c)) stop("No se pudieron extraer ids <1..62> de 'PAIS-<id>'.")
ct_r <- canon_country(country_of(rn)); ct_c <- canon_country(country_of(cn))
# Conjuntos de países (orden según aparecen en filas)
countries <- unique(ct_r)
if (!setequal(unique(ct_r), unique(ct_c))) {
stop("Los países en filas y columnas de W no coinciden tras canonizar nombres.")
}
# Índices por país
idxWr_by <- setNames(lapply(countries, function(cc) which(ct_r == cc)), countries)
idxWc_by <- setNames(lapply(countries, function(cc) which(ct_c == cc)), countries)
# Chequeo rápido: cada bloque debe contener ids 1..62 (en cualquier orden)
for (cc in countries){
iR <- idxWr_by[[cc]]; iC <- idxWc_by[[cc]]
if (!setequal(sort(id_r[iR]), 1:62)) stop("Bloque filas país ", cc, " no contiene todos los ids 1..62.")
if (!setequal(sort(id_c[iC]), 1:62)) stop("Bloque columnas país ", cc, " no contiene todos los ids 1..62.")
}
# Resultado
W_norm <- W
# Bucle por todos los pares (k,l)
for (k in seq_along(countries)){
iR <- idxWr_by[[k]]; idsR <- id_r[iR]
for (l in seq_along(countries)){
iC <- idxWc_by[[l]]; idsC <- id_c[iC]
Wkl <- W[iR, iC, drop = FALSE]
Wkl_new <- Wkl  # trabajamos sobre copia del bloque
# ---- 1) Especial × Especial (misma o distinta familia): normaliza en la submatriz ----
for (gR_name in names(SPECIAL_GROUPS)){
RR <- which(idsR %in% SPECIAL_GROUPS[[gR_name]])
if (!length(RR)) next
for (gC_name in names(SPECIAL_GROUPS)){
CC <- which(idsC %in% SPECIAL_GROUPS[[gC_name]])
if (!length(CC)) next
sub <- Wkl[RR, CC, drop = FALSE]
s <- sum(sub)
if (is.finite(s) && s > 0) {
Wkl_new[RR, CC] <- sub / s
} else {
Wkl_new[RR, CC] <- 0
}
}
}
# ---- 2) Normal × Especial: vector horizontal (fila normal sobre columnas del grupo) ----
RR_norm <- which(!idsR %in% ALL_SPECIAL_IDS)
if (length(RR_norm)){
for (gC_name in names(SPECIAL_GROUPS)){
CC <- which(idsC %in% SPECIAL_GROUPS[[gC_name]])
if (!length(CC)) next
for (rr in RR_norm){
s <- sum(Wkl[rr, CC])
if (is.finite(s) && s > 0){
Wkl_new[rr, CC] <- Wkl[rr, CC] / s
} else {
Wkl_new[rr, CC] <- 0
}
}
}
}
# ---- 3) Especial × Normal: vector vertical (filas del grupo sobre columna normal) ----
CC_norm <- which(!idsC %in% ALL_SPECIAL_IDS)
if (length(CC_norm)){
for (gR_name in names(SPECIAL_GROUPS)){
RR <- which(idsR %in% SPECIAL_GROUPS[[gR_name]])
if (!length(RR)) next
for (cc in CC_norm){
s <- sum(Wkl[RR, cc])
if (is.finite(s) && s > 0){
Wkl_new[RR, cc] <- Wkl[RR, cc] / s
} else {
Wkl_new[RR, cc] <- 0
}
}
}
}
# ---- 4) Normal × Normal: celda !=0 → 1 ; 0 → 0 ----
RR_base <- which(!idsR %in% ALL_SPECIAL_IDS)
CC_base <- which(!idsC %in% ALL_SPECIAL_IDS)
if (length(RR_base) && length(CC_base)){
base_block <- Wkl[RR_base, CC_base, drop = FALSE]
Wkl_new[RR_base, CC_base] <- ifelse(base_block != 0, 1, 0)
}
# Vuelca el bloque normalizado
W_norm[iR, iC] <- Wkl_new
}
}
W_norm
}
# ---------------- Script principal ----------------
# 1) Lee W.xlsx
W <- read_W_matrix("W.xlsx")
# 2) Normaliza por reglas para TODOS los pares de países
W_norm <- normalize_W_global(W)
# 3) Exporta resultado
openxlsx::write.xlsx(as.data.frame(W_norm), file = "W_normalizada.xlsx",
rowNames = TRUE, overwrite = TRUE)
cat("Listo: 'W_normalizada.xlsx' generado.
")
# Chequeo general de la matriz normalizada
check_normalized_matrix <- function(W_normalized, W_original, groups, eps = 1e-8) {
n_ctry <- length(unique(extract_id(rownames(W_normalized))))
result <- data.frame(country_r = character(), country_c = character(), row_id = integer(), col_id = integer(), result = character())
for (k in 1:n_ctry) {
for (l in 1:n_ctry) {
# Extrae los índices de fila y columna por país
iR <- idxWr_by[[k]]
iC <- idxWc_by[[l]]
Wkl_normalized <- W_normalized[iR, iC, drop = FALSE]
Wkl_original <- W_original[iR, iC, drop = FALSE]
# Recorre todas las celdas de la submatriz correspondiente
for (r in 1:length(iR)) {
for (c in 1:length(iC)) {
r_id <- extract_id(rownames(W_normalized)[iR[r]])
c_id <- extract_id(colnames(W_normalized)[iC[c]])
# Verifica si las filas y columnas son normales
g_row <- names(Filter(function(g) r_id %in% g, groups))
g_col <- names(Filter(function(g) c_id %in% g, groups))
# Caso 1: Si la fila y la columna son de subgrupos especiales, verificar que la matriz cuadrada da 1
if (length(g_row) && length(g_col) && g_row == g_col) {
Sg <- sum(Wkl_original[which(extract_id(rownames(W_normalized)) %in% groups[[g_row]]),
which(extract_id(colnames(W_normalized)) %in% groups[[g_col]])])
if (abs(Sg) > eps) {
expected_value <- Wkl_original[r, c] / Sg
if (abs(expected_value - 1) > eps) {
result <- rbind(result, data.frame(country_r = rownames(W_normalized)[iR[r]],
country_c = colnames(W_normalized)[iC[c]],
row_id = r_id, col_id = c_id,
result = sprintf("Matriz cuadrada no normalizada correctamente: Expected %.12f, Got %.12f", 1, expected_value)))
}
}
}
# Caso 2: Si la fila es normal y la columna es especial, debe normalizarse correctamente
if (length(g_row) && !length(g_col)) {
sum_col <- sum(Wkl_original[r, which(extract_id(colnames(W_normalized)) %in% groups[[g_col]])])
if (abs(sum_col) > eps) {
expected_value <- Wkl_original[r, c] / sum_col
if (abs(expected_value - 1) > eps) {
result <- rbind(result, data.frame(country_r = rownames(W_normalized)[iR[r]],
country_c = colnames(W_normalized)[iC[c]],
row_id = r_id, col_id = c_id,
result = sprintf("Normalización vertical incorrecta: Expected %.12f, Got %.12f", 1, expected_value)))
}
}
}
# Caso 3: Si la columna es normal y la fila es especial, debe normalizarse correctamente
if (!length(g_row) && length(g_col)) {
sum_row <- sum(Wkl_original[which(extract_id(rownames(W_normalized)) %in% groups[[g_row]]), c])
if (abs(sum_row) > eps) {
expected_value <- Wkl_original[r, c] / sum_row
if (abs(expected_value - 1) > eps) {
result <- rbind(result, data.frame(country_r = rownames(W_normalized)[iR[r]],
country_c = colnames(W_normalized)[iC[c]],
row_id = r_id, col_id = c_id,
result = sprintf("Normalización horizontal incorrecta: Expected %.12f, Got %.12f", 1, expected_value)))
}
}
}
}
}
}
}
if (nrow(result) == 0) {
cat("Todos los cheques pasados correctamente. La normalización está correcta.\n")
} else {
cat("Errores encontrados en la normalización. Revisa los resultados.\n")
}
return(result)
}
# Ejecutamos la comprobación con la matriz normalizada
result_check <- check_normalized_matrix(W_normalized, W0, groups)
# Chequeo general de la matriz normalizada
check_normalized_matrix <- function(W_norm, W_original, groups, eps = 1e-8) {
n_ctry <- length(unique(extract_id(rownames(W_norm))))
result <- data.frame(country_r = character(), country_c = character(), row_id = integer(), col_id = integer(), result = character())
for (k in 1:n_ctry) {
for (l in 1:n_ctry) {
# Extrae los índices de fila y columna por país
iR <- idxWr_by[[k]]
iC <- idxWc_by[[l]]
Wkl_normalized <- W_norm[iR, iC, drop = FALSE]
Wkl_original <- W_original[iR, iC, drop = FALSE]
# Recorre todas las celdas de la submatriz correspondiente
for (r in 1:length(iR)) {
for (c in 1:length(iC)) {
r_id <- extract_id(rownames(W_norm)[iR[r]])
c_id <- extract_id(colnames(W_norm)[iC[c]])
# Verifica si las filas y columnas son normales
g_row <- names(Filter(function(g) r_id %in% g, groups))
g_col <- names(Filter(function(g) c_id %in% g, groups))
# Caso 1: Si la fila y la columna son de subgrupos especiales, verificar que la matriz cuadrada da 1
if (length(g_row) && length(g_col) && g_row == g_col) {
Sg <- sum(Wkl_original[which(extract_id(rownames(W_norm)) %in% groups[[g_row]]),
which(extract_id(colnames(W_norm)) %in% groups[[g_col]])])
if (abs(Sg) > eps) {
expected_value <- Wkl_original[r, c] / Sg
if (abs(expected_value - 1) > eps) {
result <- rbind(result, data.frame(country_r = rownames(W_norm)[iR[r]],
country_c = colnames(W_norm)[iC[c]],
row_id = r_id, col_id = c_id,
result = sprintf("Matriz cuadrada no normalizada correctamente: Expected %.12f, Got %.12f", 1, expected_value)))
}
}
}
# Caso 2: Si la fila es normal y la columna es especial, debe normalizarse correctamente
if (length(g_row) && !length(g_col)) {
sum_col <- sum(Wkl_original[r, which(extract_id(colnames(W_norm)) %in% groups[[g_col]])])
if (abs(sum_col) > eps) {
expected_value <- Wkl_original[r, c] / sum_col
if (abs(expected_value - 1) > eps) {
result <- rbind(result, data.frame(country_r = rownames(W_norm)[iR[r]],
country_c = colnames(W_norm)[iC[c]],
row_id = r_id, col_id = c_id,
result = sprintf("Normalización vertical incorrecta: Expected %.12f, Got %.12f", 1, expected_value)))
}
}
}
# Caso 3: Si la columna es normal y la fila es especial, debe normalizarse correctamente
if (!length(g_row) && length(g_col)) {
sum_row <- sum(Wkl_original[which(extract_id(rownames(W_norm)) %in% groups[[g_row]]), c])
if (abs(sum_row) > eps) {
expected_value <- Wkl_original[r, c] / sum_row
if (abs(expected_value - 1) > eps) {
result <- rbind(result, data.frame(country_r = rownames(W_norm)[iR[r]],
country_c = colnames(W_norm)[iC[c]],
row_id = r_id, col_id = c_id,
result = sprintf("Normalización horizontal incorrecta: Expected %.12f, Got %.12f", 1, expected_value)))
}
}
}
}
}
}
}
if (nrow(result) == 0) {
cat("Todos los cheques pasados correctamente. La normalización está correcta.\n")
} else {
cat("Errores encontrados en la normalización. Revisa los resultados.\n")
}
return(result)
}
# Ejecutamos la comprobación con la matriz normalizada
result_check <- check_normalized_matrix(W_norm, W0, groups)
# === Helpers para la normalización de la matriz W ===
# Función para limpiar nombres
clean_names <- function(x){
x <- trimws(x)
x <- gsub("\\.-\\.", "-", x)  # Corrige las expresiones regulares
x <- gsub("\\s*-\\s*", "-", x)  # Elimina los espacios antes/después de los guiones
x <- gsub("[–—−]", "-", x)  # Reemplaza otros tipos de guiones por "-"
toupper(x)  # Convierte todo a mayúsculas
}
# Funciones para extraer la información de países y sectores
country_of  <- function(x) sub("-\\d+$", "", x)
extract_id  <- function(x) as.integer(sub(".*-(\\d+)$", "\\1", x))
canon_country <- function(x){ x <- clean_names(x); gsub("[^A-Z0-9]", "", x) }
# Grupos definidos (según canvas)
G5  <- 9:17
G39 <- 47:49
G37 <- 50:51
B_base <- c(1:8, 18:46, 52:62)  # Sectores normales (de acuerdo a tu definición)
groups <- list(G5 = G5, G39 = G39, G37 = G37)
# Carga matrices (W0 original y W1 normalizada)
W0 <- as.matrix(read.xlsx("W.xlsx", sheet = 1, colNames = TRUE, rowNames = TRUE))
W1 <- as.matrix(read.xlsx("W_WILI_CGE.xlsx", sheet = 1, colNames = TRUE, rowNames = TRUE))
# Índices de países y sectores
rn <- clean_names(rownames(W0)); cn <- clean_names(colnames(W0))
ct_r <- canon_country(country_of(rn)); ct_c <- canon_country(country_of(cn))
ids_r <- extract_id(rn); ids_c <- extract_id(cn)
countries <- unique(ct_r)
idxWr_by <- setNames(lapply(countries, function(cc) which(ct_r == cc)), countries)
idxWc_by <- setNames(lapply(countries, function(cc) which(ct_c == cc)), countries)
# Tolerancias para los errores
eps <- 1e-8
tol <- 1e-12
# Comprobación por celdas de la matriz
check_normalized_matrix <- function(W_normalized, W_original, groups, eps = 1e-8) {
n_ctry <- length(unique(extract_id(rownames(W_normalized))))
result <- data.frame(country_r = character(), country_c = character(), row_id = integer(), col_id = integer(), result = character())
for (k in 1:n_ctry) {
for (l in 1:n_ctry) {
# Extrae los índices de fila y columna por país
iR <- idxWr_by[[k]]
iC <- idxWc_by[[l]]
Wkl_normalized <- W_normalized[iR, iC, drop = FALSE]
Wkl_original <- W_original[iR, iC, drop = FALSE]
# Recorre todas las celdas de la submatriz correspondiente
for (r in 1:length(iR)) {
for (c in 1:length(iC)) {
r_id <- extract_id(rownames(W_normalized)[iR[r]])
c_id <- extract_id(colnames(W_normalized)[iC[c]])
# Verifica si las filas y las columnas son normales o pertenecen a un subgrupo especial
g_row <- names(Filter(function(g) r_id %in% g, groups))
g_col <- names(Filter(function(g) c_id %in% g, groups))
# Caso 1: Si la fila y la columna pertenecen a un subgrupo especial, se usa la matriz cuadrada
if (length(g_row) && length(g_col) && g_row == g_col) {
Sg <- sum(Wkl_original[which(ids_r %in% groups[[g_row]]),
which(ids_c %in% groups[[g_col]])])
if (abs(Sg) > eps) {
expected_value <- Wkl_original[r, c] / Sg
if (abs(expected_value - 1) > eps) {
result <- rbind(result, data.frame(country_r = rownames(W_normalized)[iR[r]],
country_c = colnames(W_normalized)[iC[c]],
row_id = r_id, col_id = c_id,
result = sprintf("Matriz cuadrada no normalizada correctamente: Expected %.12f, Got %.12f", 1, expected_value)))
}
}
}
# Caso 2: Si la fila es normal y la columna es especial, se debe normalizar verticalmente
if (!length(g_row) && length(g_col)) {
g <- groups[[g_col]]
RR <- which(ids_r %in% g)
Sc <- sum(Wkl_original[RR, c], na.rm = TRUE)
if (abs(Sc) > eps) {
expected_value <- Wkl_original[r, c] / Sc
if (abs(expected_value - 1) > eps) {
result <- rbind(result, data.frame(country_r = rownames(W_normalized)[iR[r]],
country_c = colnames(W_normalized)[iC[c]],
row_id = r_id, col_id = c_id,
result = sprintf("Normalización vertical incorrecta: Expected %.12f, Got %.12f", 1, expected_value)))
}
}
}
# Caso 3: Si la columna es normal y la fila es especial, se debe normalizar horizontalmente
if (length(g_row) && !length(g_col)) {
g <- groups[[g_row]]
CC <- which(ids_c %in% g)
Sr <- sum(Wkl_original[r, CC], na.rm = TRUE)
if (abs(Sr) > eps) {
expected_value <- Wkl_original[r, c] / Sr
if (abs(expected_value - 1) > eps) {
result <- rbind(result, data.frame(country_r = rownames(W_normalized)[iR[r]],
country_c = colnames(W_normalized)[iC[c]],
row_id = r_id, col_id = c_id,
result = sprintf("Normalización horizontal incorrecta: Expected %.12f, Got %.12f", 1, expected_value)))
}
}
}
}
}
}
}
if (nrow(result) == 0) {
cat("Todos los cheques pasados correctamente. La normalización está correcta.\n")
} else {
cat("Errores encontrados en la normalización. Revisa los resultados.\n")
}
return(result)
}
# Ejecutamos la comprobación con la matriz normalizada
result_check <- check_normalized_matrix(W1, W0, groups)
# Mostrar los resultados
if (nrow(result_check) > 0) {
print(result_check)
} else {
cat("Todo parece correcto en la normalización.\n")
# === Helpers para la normalización de la matriz W ===
# Función para limpiar nombres
clean_names <- function(x){
x <- trimws(x)
x <- gsub("\\.-\\.", "-", x)  # Corrige las expresiones regulares
x <- gsub("\\s*-\\s*", "-", x)  # Elimina los espacios antes/después de los guiones
x <- gsub("[–—−]", "-", x)  # Reemplaza otros tipos de guiones por "-"
toupper(x)  # Convierte todo a mayúsculas
}
# Funciones para extraer la información de países y sectores
country_of  <- function(x) sub("-\\d+$", "", x)
extract_id  <- function(x) as.integer(sub(".*-(\\d+)$", "\\1", x))
canon_country <- function(x){ x <- clean_names(x); gsub("[^A-Z0-9]", "", x) }
# Grupos definidos (según canvas)
G5  <- 9:17
G39 <- 47:49
G37 <- 50:51
G6_21 <- c(6, 21)  # Subgrupo especial
B_base <- c(1:8, 18:46, 52:62)  # Sectores normales (de acuerdo a tu definición)
groups <- list(G5 = G5, G39 = G39, G37 = G37, G6_21 = G6_21)
# Carga matrices (W0 original y W1 normalizada)
W0 <- as.matrix(read.xlsx("W.xlsx", sheet = 1, colNames = TRUE, rowNames = TRUE))
W1 <- as.matrix(read.xlsx("W_WILI_CGE.xlsx", sheet = 1, colNames = TRUE, rowNames = TRUE))
# Índices de países y sectores
rn <- clean_names(rownames(W0)); cn <- clean_names(colnames(W0))
ct_r <- canon_country(country_of(rn)); ct_c <- canon_country(country_of(cn))
ids_r <- extract_id(rn); ids_c <- extract_id(cn)
countries <- unique(ct_r)
idxWr_by <- setNames(lapply(countries, function(cc) which(ct_r == cc)), countries)
idxWc_by <- setNames(lapply(countries, function(cc) which(ct_c == cc)), countries)
# Tolerancias para los errores
eps <- 1e-8
tol <- 1e-12
# Comprobación por celdas de la matriz
check_normalized_matrix <- function(W_normalized, W_original, groups, eps = 1e-8) {
n_ctry <- length(unique(extract_id(rownames(W_normalized))))
result <- data.frame(country_r = character(), country_c = character(), row_id = integer(), col_id = integer(), result = character())
for (k in 1:n_ctry) {
for (l in 1:n_ctry) {
# Extrae los índices de fila y columna por país
iR <- idxWr_by[[k]]
iC <- idxWc_by[[l]]
Wkl_normalized <- W_normalized[iR, iC, drop = FALSE]
Wkl_original <- W_original[iR, iC, drop = FALSE]
# Recorre todas las celdas de la submatriz correspondiente
for (r in 1:length(iR)) {
for (c in 1:length(iC)) {
r_id <- extract_id(rownames(W_normalized)[iR[r]])
c_id <- extract_id(colnames(W_normalized)[iC[c]])
# Verifica si las filas y las columnas son normales o pertenecen a un subgrupo especial
g_row <- names(Filter(function(g) r_id %in% g, groups))
g_col <- names(Filter(function(g) c_id %in% g, groups))
# Caso 1: Si la fila y la columna pertenecen a un subgrupo especial, se usa la matriz cuadrada
if (length(g_row) && length(g_col) && g_row == g_col) {
Sg <- sum(Wkl_original[which(ids_r %in% groups[[g_row]]),
which(ids_c %in% groups[[g_col]])])
if (abs(Sg) > eps) {
expected_value <- Wkl_original[r, c] / Sg
if (abs(expected_value - 1) > eps) {
result <- rbind(result, data.frame(country_r = rownames(W_normalized)[iR[r]],
country_c = colnames(W_normalized)[iC[c]],
row_id = r_id, col_id = c_id,
result = sprintf("Matriz cuadrada no normalizada correctamente: Expected %.12f, Got %.12f", 1, expected_value)))
}
}
}
# Caso 2: Si la fila es normal y la columna es especial, se debe normalizar verticalmente
if (!length(g_row) && length(g_col)) {
g <- groups[[g_col]]
RR <- which(ids_r %in% g)
Sc <- sum(Wkl_original[RR, c], na.rm = TRUE)
if (abs(Sc) > eps) {
expected_value <- Wkl_original[r, c] / Sc
if (abs(expected_value - 1) > eps) {
result <- rbind(result, data.frame(country_r = rownames(W_normalized)[iR[r]],
country_c = colnames(W_normalized)[iC[c]],
row_id = r_id, col_id = c_id,
result = sprintf("Normalización vertical incorrecta: Expected %.12f, Got %.12f", 1, expected_value)))
}
}
}
# Caso 3: Si la columna es normal y la fila es especial, se debe normalizar horizontalmente
if (length(g_row) && !length(g_col)) {
g <- groups[[g_row]]
CC <- which(ids_c %in% g)
Sr <- sum(Wkl_original[r, CC], na.rm = TRUE)
if (abs(Sr) > eps) {
expected_value <- Wkl_original[r, c] / Sr
if (abs(expected_value - 1) > eps) {
result <- rbind(result, data.frame(country_r = rownames(W_normalized)[iR[r]],
country_c = colnames(W_normalized)[iC[c]],
row_id = r_id, col_id = c_id,
result = sprintf("Normalización horizontal incorrecta: Expected %.12f, Got %.12f", 1, expected_value)))
}
}
}
}
}
}
}
if (nrow(result) == 0) {
cat("Todos los cheques pasados correctamente. La normalización está correcta.\n")
} else {
cat("Errores encontrados en la normalización. Revisa los resultados.\n")
}
return(result)
}
# Ejecutamos la comprobación con la matriz normalizada
result_check <- check_normalized_matrix(W1, W0, groups)
# Mostrar los resultados
if (nrow(result_check) > 0) {
print(result_check)
} else {
cat("Todo parece correcto en la normalización.\n")
}
# === Helpers para la normalización de la matriz W ===
# Función para limpiar nombres
clean_names <- function(x){
x <- trimws(x)
x <- gsub("\\.-\\.", "-", x)  # Corrige las expresiones regulares
x <- gsub("\\s*-\\s*", "-", x)  # Elimina los espacios antes/después de los guiones
x <- gsub("[–—−]", "-", x)  # Reemplaza otros tipos de guiones por "-"
toupper(x)  # Convierte todo a mayúsculas
}
