mutate(out_sec_uz = as.character(out_sec_uz),
in_sec_uz = as.character(in_sec_uz)
)
# save(unizar_pivot,file = "./DataRafa/unizar_pivot.RData")
load("./DataRafa/unizar_pivot.RData")
# save(unizar_pivot,file = "./Data_CT/unizar_pivot.RData")
load("./Data_CT/unizar_pivot.RData")
#**MWMWMWMWMMWMWMWMWMMWMWMWMWMMWMWMWMWMMWMWMWMWMMWMWMWMWMMWMWMWMWM
# CARGAR Y LIMPIAR WILIAM -------------
# cargar matriz tocha
W_norm <- read.xlsx("W_normalizada.xlsx")
# pivotar a lo largo. Primero tengo que preparar la matriz, y despues de pivotar algo algo muy similar a lo que hacía con unizar
wiliam_pivot <- W_norm |>
rename(in_wil = 1) |>
separate(in_wil, into = c("in_cou", "in_sec_wi"), sep = "-") |>
pivot_longer(cols = -c("in_cou", "in_sec_wi"), names_to = "tmp", values_to = "wiliam_values") |>
separate(tmp, into = c("out_cou", "out_sec_wi"), sep = "-")
# save(wiliam_pivot,file = "./Data_CT/wiliam_pivot.RData")
load("./Data_CT/wiliam_pivot.RData")
#**MWMWMWMWMMWMWMWMWMMWMWMWMWMMWMWMWMWMMWMWMWMWMMWMWMWMWMMWMWMWMWM
# UNIRRLAS TABLAS POR FIN ----------------------
# limiar todo menos mis dos matrices pivotadas
rm(list = setdiff(ls(), c("wiliam_pivot", "unizar_pivot")))
# la tabla nexo
sector_join <- read.xlsx("Correspondance_final.xlsx", sheet = "Rafa_intermediate_wili") |>
mutate_all(~as.character(.)) #importante que sea caracter
# la tabla nexo
sector_join <- read.xlsx("info/Correspondance_final.xlsx", sheet = "Rafa_intermediate_wili") |>
mutate_all(~as.character(.)) #importante que sea caracter
# la tabla nexo
sector_join <- read.xlsx("info\Correspondance_final.xlsx", sheet = "Rafa_intermediate_wili") |>
# la tabla nexo
sector_join <- read.xlsx("./info/Correspondance_final.xlsx", sheet = "Rafa_intermediate_wili") |>
mutate_all(~as.character(.)) #importante que sea caracter
rm(list = setdiff(ls(), c("wiliam_pivot", "unizar_pivot")))
# la tabla nexo
sector_join <- read.xlsx("./info/Correspondance_final.xlsx", sheet = "Rafa_intermediate_wili") |>
mutate_all(~as.character(.)) #importante que sea caracter
# check nombres de paises y sectores
a = distinct(wiliam_pivot |> select(in_cou))
b = distinct(unizar_pivot |> select(in_cou))
a == b
a = distinct(wiliam_pivot |> select(out_cou))
b = distinct(unizar_pivot |> select(out_cou))
a == b
a = distinct(wiliam_pivot |> select(in_sec_wi) |> arrange(in_sec_wi))
b = distinct(sector_join |> select(code_wi)|> arrange(code_wi))
a == b
# hago la union de la tabla nexo con la de wiliam. Uno primero los setores IN y despues OUT
# importante le cambio el nombre  para que esté acode
wiliam_join <- wiliam_pivot |>
left_join(sector_join |> rename(in_sec_uz = code_za), by = c("in_sec_wi" = "code_wi")) |>
left_join(sector_join |> rename(out_sec_uz = code_za), by = c("out_sec_wi" = "code_wi"))
# ahora que tiene bien el nexo, procedo a attach la matriz
# con el full_join me aseguro de que "duplican" los valores de zar para que no queden huecos libres
# en la matriz final ( que debe tener el tamaño de wili)
# para que se una tiene qie cumpler que sean iguales: pais de entrada, salida, y los sectores de entrada y salida de unizar
wiliam_unizar <- wiliam_join |>
full_join(unizar_pivot,
by = c("in_cou", "out_cou", "in_sec_uz", "out_sec_uz"))
# save(wiliam_unizar,file = "./Data_CT/wiliam_unizar.RData")
load("./Data_CT/wiliam_unizar.RData")
# ahora calculo el prodcuto (wiliam_values * unizar_values)
# limpio la matriz y la preparo para su pivote
# y la pivoto a lo ancho
wiliam_wide_c <- wiliam_unizar |>
mutate(values = wiliam_values * unizar_values) |>
unite(c("in_cou", "in_sec_wi"), col = "insecou") |>
unite(c("out_cou", "out_sec_wi"), col = "outsecou") |>
select(-c("in_sec_uz", "out_sec_uz", "unizar_values", "wiliam_values")) |>
pivot_wider(names_from = "outsecou", values_from = "values")
save(wiliam_wide_c, file = "./Data_CT/wiliam_wide_c.RData")
# write.xlsx(wiliam_wide_c, "IO_wiliam_rafa.xlsx")
# ============================================================
# COMPROBACIONES (versión tidy) para flujo Rafa
#   Entrada esperada en memoria (de tu script):
#     - wiliam_unizar: long table con columnas
#         in_cou, out_cou, in_sec_wi, out_sec_wi,
#         in_sec_uz, out_sec_uz, wiliam_values, unizar_values
#     - (opcional) wiliam_wide_c: matriz ancha final (para contraste)
#   Objetivo: verificar que se cumplen las normas de
#     "multiplicar → colocar" con expansiones y remapeos.
# ============================================================
suppressPackageStartupMessages({ library(tidyverse) })
# ---------------- Helpers ----------------
.to_int <- function(x){ suppressWarnings(as.integer(as.character(x))) }
.na0   <- function(x){ dplyr::coalesce(x, 0) }
special_children <- list(
`5`  = 9:17,
`8`  = c(6,21),
`37` = 50:51,
`39` = 47:49,
`45` = 58:62
)
remap <- c(`7`=5L, `34`=43L)
base_set <- setdiff(1:48, c(5,7,8,34,37,39,45))
# Normaliza tipos y calcula el producto (wili * unizar)
prep_wu <- function(wu){
stopifnot(all(c("in_cou","out_cou","in_sec_wi","out_sec_wi",
"in_sec_uz","out_sec_uz","wiliam_values","unizar_values") %in% names(wu)))
wu %>%
mutate(
across(c(in_sec_wi,out_sec_wi,in_sec_uz,out_sec_uz), .fns=.to_int),
across(c(wiliam_values, unizar_values), as.numeric),
wiliam_values = .na0(wiliam_values),
unizar_values = .na0(unizar_values),
prod = wiliam_values * unizar_values
)
}
# ---------------- CHECK 0: salud del join / tipos ----------------
check_0_health <- function(wu){
tibble(
n_total = nrow(wu),
n_na_wili = sum(is.na(wu$wiliam_values)),
n_na_uniz = sum(is.na(wu$unizar_values)),
n_zero_prod = sum(wu$prod == 0, na.rm=TRUE)
)
}
# ---------------- CHECK 1: base×base (identidad de mapeo) --------
# Reglas esperadas:
#  - Si in_sec_uz ∈ base y out_sec_uz ∈ base ⇒ in_sec_wi == in_sec_uz y out_sec_wi == out_sec_uz
#  - El valor final es simplemente unizar * wili (que ya es wu$prod)
check_1_base_base <- function(wu){
bb <- wu %>% filter(in_sec_uz %in% base_set, out_sec_uz %in% base_set)
viol <- bb %>%
filter(in_sec_wi != in_sec_uz | out_sec_wi != out_sec_uz) %>%
count(in_cou, out_cou, name="n_viol") %>% arrange(desc(n_viol))
list(
summary = bb %>% summarise(n=n(), n_viol=nrow(viol), share_viol = n_viol/max(n,1)),
top_viol = head(viol, 20)
)
}
# ---------------- CHECK 2: remapeos 7→5 y 34→43 ------------------
# Reglas esperadas (sin expansión):
#  - in_sec_uz==7 ⇒ in_sec_wi==5 ;  in_sec_uz==34 ⇒ in_sec_wi==43
#  - out_sec_uz==7 ⇒ out_sec_wi==5 ; out_sec_uz==34 ⇒ out_sec_wi==43
check_2_remaps <- function(wu){
rem_in  <- bind_rows(
wu %>% filter(in_sec_uz==7)  %>% mutate(exp=5,  got=in_sec_wi,  where="in",  who="7→5"),
wu %>% filter(in_sec_uz==34) %>% mutate(exp=43, got=in_sec_wi,  where="in",  who="34→43")
) %>% mutate(ok = got==exp)
rem_out <- bind_rows(
wu %>% filter(out_sec_uz==7)  %>% mutate(exp=5,  got=out_sec_wi, where="out", who="7→5"),
wu %>% filter(out_sec_uz==34) %>% mutate(exp=43, got=out_sec_wi, where="out", who="34→43")
) %>% mutate(ok = got==exp)
list(
in_summary  = rem_in  %>% summarise(n=n(), n_bad=sum(!ok), share_bad = n_bad/max(n,1)),
out_summary = rem_out %>% summarise(n=n(), n_bad=sum(!ok), share_bad = n_bad/max(n,1)),
worst_in  = rem_in  %>% filter(!ok) %>% count(in_cou,out_cou,who,got,exp, name="n") %>% arrange(desc(n)) %>% head(20),
worst_out = rem_out %>% filter(!ok) %>% count(in_cou,out_cou,who,got,exp, name="n") %>% arrange(desc(n)) %>% head(20)
)
}
# ---------------- CHECK 3: expansión por COLUMNAS ----------------
# Regla: r ∈ base, c ∈ {5,8,37,39,45} ⇒ se reparte por hijos de c (vector)
#       Debe haber EXACTAMENTE |children(c)| filas con out_sec_wi ∈ children(c)
check_3_col_expansion <- function(wu){
exp_col <- map_dfr(names(special_children), function(pc){
kids <- special_children[[pc]]
wu %>% filter(out_sec_uz == as.integer(pc), in_sec_uz %in% base_set) %>%
mutate(miss = !(out_sec_wi %in% kids)) %>%
group_by(in_cou,out_cou,in_sec_uz,out_sec_uz) %>%
summarise(
n_rows = n(),
expected = length(kids),
n_wrong = sum(miss),
has_all = n_rows == expected && n_wrong==0,
sum_prod = sum(prod, na.rm=TRUE),
.groups="drop"
) %>% mutate(children = paste(kids, collapse=","))
})
list(
resumen = exp_col %>% summarise(n=n(), n_all_ok = sum(has_all), share_ok = n_all_ok/max(n,1)),
peores  = exp_col %>% filter(!has_all) %>% arrange(desc(n_wrong)) %>% head(20)
)
}
# ---------------- CHECK 4: expansión por FILAS -------------------
# Regla: r ∈ {5,8,37,39,45}, c ∈ base ⇒ se reparte por hijos de r (vector)
check_4_row_expansion <- function(wu){
exp_row <- map_dfr(names(special_children), function(pr){
kids <- special_children[[pr]]
wu %>% filter(in_sec_uz == as.integer(pr), out_sec_uz %in% base_set) %>%
mutate(miss = !(in_sec_wi %in% kids)) %>%
group_by(in_cou,out_cou,in_sec_uz,out_sec_uz) %>%
summarise(
n_rows = n(),
expected = length(kids),
n_wrong = sum(miss),
has_all = n_rows == expected && n_wrong==0,
sum_prod = sum(prod, na.rm=TRUE),
.groups="drop"
) %>% mutate(children = paste(kids, collapse=","))
})
list(
resumen = exp_row %>% summarise(n=n(), n_all_ok = sum(has_all), share_ok = n_all_ok/max(n,1)),
peores  = exp_row %>% filter(!has_all) %>% arrange(desc(n_wrong)) %>% head(20)
)
}
# ---------------- CHECK 5: bloques especial×especial --------------
# Regla: r ∈ specials, c ∈ specials ⇒ debe existir la malla hijos(r) × hijos(c)
check_5_block_specials <- function(wu){
sp_ids <- as.integer(names(special_children))
combos <- expand_grid(pr = sp_ids, pc = sp_ids)
out <- pmap_dfr(combos, function(pr, pc){
RR <- special_children[[as.character(pr)]]
CC <- special_children[[as.character(pc)]]
wu %>% filter(in_sec_uz==pr, out_sec_uz==pc) %>%
mutate(ok_r = in_sec_wi %in% RR, ok_c = out_sec_wi %in% CC) %>%
group_by(in_cou,out_cou,in_sec_uz,out_sec_uz) %>%
summarise(
n_rows = n(), expected = length(RR)*length(CC),
n_miss_r = sum(!ok_r), n_miss_c = sum(!ok_c),
has_all = (n_rows==expected && n_miss_r==0 && n_miss_c==0),
sum_prod = sum(prod, na.rm=TRUE),
.groups="drop"
) %>% mutate(pair = paste0(pr,"×",pc), need_grid = paste0("(",paste(RR,collapse=","),")×(",paste(CC,collapse=","),")"))
})
list(
resumen = out %>% summarise(n=n(), n_all_ok=sum(has_all), share_ok=n_all_ok/max(n,1)),
peores  = out %>% filter(!has_all) %>% arrange(desc(expected - n_rows), desc(n_miss_r+n_miss_c)) %>% head(20)
)
}
# ---------------- CHECK 6: no fugas a hijos equivocados -----------
# Regla: si out_sec_uz es especial ⇒ out_sec_wi debe pertenecer a children(out_sec_uz) (y análogo por filas)
check_6_no_leaks <- function(wu){
# Columnas
leak_col <- map_dfr(names(special_children), function(pc){
kids <- special_children[[pc]]
wu %>% filter(out_sec_uz == as.integer(pc)) %>%
mutate(leak = !(out_sec_wi %in% kids)) %>%
summarise(group=paste0("c:",pc), leaks = sum(leak), n=n(), share_leak=leaks/max(n,1))
})
# Filas
leak_row <- map_dfr(names(special_children), function(pr){
kids <- special_children[[pr]]
wu %>% filter(in_sec_uz == as.integer(pr)) %>%
mutate(leak = !(in_sec_wi %in% kids)) %>%
summarise(group=paste0("r:",pr), leaks = sum(leak), n=n(), share_leak=leaks/max(n,1))
})
bind_rows(leak_col, leak_row) %>% arrange(desc(leaks))
}
# ---------------- (Opcional) contraste con matriz ancha -------------
# Vuelve a calcular la matriz ancha y contrástala con wiliam_wide_c si la tienes
check_7_contrast_wide <- function(wu, wide_mat = NULL){
recalc <- wu %>%
mutate(
insecou  = paste(in_cou, in_sec_wi, sep="-"),
outsecou = paste(out_cou, out_sec_wi, sep="-")
) %>%
select(insecou,outsecou,prod) %>%
group_by(insecou,outsecou) %>% summarise(prod = sum(prod, na.rm=TRUE), .groups="drop") %>%
pivot_wider(names_from=outsecou, values_from=prod, values_fill=0)
if (is.null(wide_mat)) return(list(recalc=recalc, diff_summary=NULL))
# Alinea columnas y filas por nombre
common_rows <- intersect(recalc$insecou, wide_mat[[1]] %||% character())
# Si wide_mat es un data.frame con primera columna = fila, ajústalo aquí si quieres.
message("[check_7] Si necesitas contraste exacto con wiliam_wide_c,")
message("          pásame la estructura concreta de esa tabla (cómo vienen las filas).")
list(recalc=recalc, diff_summary=NULL)
}
# ---------------- RUN ALL ----------------
run_all_checks <- function(wiliam_unizar, wiliam_wide_c=NULL){
wu <- prep_wu(wiliam_unizar)
out <- list()
out$health <- check_0_health(wu)
out$base_base <- check_1_base_base(wu)
out$remaps <- check_2_remaps(wu)
out$col_exp <- check_3_col_expansion(wu)
out$row_exp <- check_4_row_expansion(wu)
out$block_sp <- check_5_block_specials(wu)
out$no_leaks <- check_6_no_leaks(wu)
out$contrast <- check_7_contrast_wide(wu, wiliam_wide_c)
out
}
# ================= EJEMPLO DE USO =================
# asumiendo que ya tienes cargado en memoria:
#   load("./DataRafa/wiliam_unizar.RData")
#   load("./DataRafa/wiliam_wide_c.RData")   # opcional
res_chk <- run_all_checks(wiliam_unizar, wiliam_wide_c)
res_chk$health
res_chk$base_base$summary; res_chk$base_base$top_viol
res_chk$remaps$in_summary;  res_chk$remaps$out_summary
res_chk$col_exp$resumen;    res_chk$col_exp$peores
res_chk$row_exp$resumen;    res_chk$row_exp$peores
res_chk$block_sp$resumen;   res_chk$block_sp$peores
res_chk$no_leaks
res_chk$contrast$recalc  # matriz ancha recalculada desde long
res_chk <- run_all_checks(wiliam_unizar, wiliam_wide_c)
res_chk$health
res_chk$base_base$summary; res_chk$base_base$top_viol
res_chk$remaps$in_summary;  res_chk$remaps$out_summary
res_chk$col_exp$resumen;    res_chk$col_exp$peores
res_chk$row_exp$resumen;    res_chk$row_exp$peores
res_chk$block_sp$resumen;   res_chk$block_sp$peores
res_chk$no_leaks
# ============================================================
# COMPROBACIONES (versión tidy) para flujo Rafa
#   Entrada esperada en memoria (de tu script):
#     - wiliam_unizar: long table con columnas
#         in_cou, out_cou, in_sec_wi, out_sec_wi,
#         in_sec_uz, out_sec_uz, wiliam_values, unizar_values
#     - (opcional) wiliam_wide_c: matriz ancha final (para contraste)
#   Objetivo: verificar que se cumplen las normas de
#     "multiplicar → colocar" con expansiones y remapeos.
# ============================================================
suppressPackageStartupMessages({ library(tidyverse) })
# ---------------- Helpers ----------------
.to_int <- function(x){ suppressWarnings(as.integer(as.character(x))) }
.na0   <- function(x){ dplyr::coalesce(x, 0) }
special_children <- list(
`5`  = 9:17,
`8`  = c(6,21),
`37` = 50:51,
`39` = 47:49,
`45` = 58:62
)
remap <- c(`7`=5L, `34`=43L)
base_set <- setdiff(1:48, c(5,7,8,34,37,39,45))
# Normaliza tipos y calcula el producto (wili * unizar)
prep_wu <- function(wu){
stopifnot(all(c("in_cou","out_cou","in_sec_wi","out_sec_wi",
"in_sec_uz","out_sec_uz","wiliam_values","unizar_values") %in% names(wu)))
wu %>%
mutate(
across(c(in_sec_wi,out_sec_wi,in_sec_uz,out_sec_uz), .fns=.to_int),
across(c(wiliam_values, unizar_values), as.numeric),
wiliam_values = .na0(wiliam_values),
unizar_values = .na0(unizar_values),
prod = wiliam_values * unizar_values
)
}
# ---------------- CHECK 0: salud del join / tipos ----------------
check_0_health <- function(wu){
tibble(
n_total = nrow(wu),
n_na_wili = sum(is.na(wu$wiliam_values)),
n_na_uniz = sum(is.na(wu$unizar_values)),
n_zero_prod = sum(wu$prod == 0, na.rm=TRUE)
)
}
# ---------------- CHECK 1: base×base (identidad de mapeo) --------
# Reglas esperadas:
#  - Si in_sec_uz ∈ base y out_sec_uz ∈ base ⇒ in_sec_wi == in_sec_uz y out_sec_wi == out_sec_uz
#  - El valor final es simplemente unizar * wili (que ya es wu$prod)
check_1_base_base <- function(wu){
bb <- wu %>% filter(in_sec_uz %in% base_set, out_sec_uz %in% base_set)
viol_by_pair <- bb %>%
filter(in_sec_wi != in_sec_uz | out_sec_wi != out_sec_uz) %>%
count(in_cou, out_cou, name="n_viol") %>% arrange(desc(n_viol))
summary_tbl <- bb %>%
summarise(
n = n(),
n_viol = sum(in_sec_wi != in_sec_uz | out_sec_wi != out_sec_uz),
share_viol = n_viol / max(n,1)
)
list(
summary = summary_tbl,
top_viol = head(viol_by_pair, 20)
)
}
# ---------------- CHECK 2: remapeos 7→5 y 34→43 ------------------
# Reglas esperadas (sin expansión):
#  - in_sec_uz==7 ⇒ in_sec_wi==5 ;  in_sec_uz==34 ⇒ in_sec_wi==43
#  - out_sec_uz==7 ⇒ out_sec_wi==5 ; out_sec_uz==34 ⇒ out_sec_wi==43
check_2_remaps <- function(wu){
rem_in  <- bind_rows(
wu %>% filter(in_sec_uz==7)  %>% mutate(exp=5,  got=in_sec_wi,  where="in",  who="7→5"),
wu %>% filter(in_sec_uz==34) %>% mutate(exp=43, got=in_sec_wi,  where="in",  who="34→43")
) %>% mutate(ok = got==exp)
rem_out <- bind_rows(
wu %>% filter(out_sec_uz==7)  %>% mutate(exp=5,  got=out_sec_wi, where="out", who="7→5"),
wu %>% filter(out_sec_uz==34) %>% mutate(exp=43, got=out_sec_wi, where="out", who="34→43")
) %>% mutate(ok = got==exp)
list(
in_summary  = rem_in  %>% summarise(n=n(), n_bad=sum(!ok), share_bad = n_bad/max(n,1)),
out_summary = rem_out %>% summarise(n=n(), n_bad=sum(!ok), share_bad = n_bad/max(n,1)),
worst_in  = rem_in  %>% filter(!ok) %>% count(in_cou,out_cou,who,got,exp, name="n") %>% arrange(desc(n)) %>% head(20),
worst_out = rem_out %>% filter(!ok) %>% count(in_cou,out_cou,who,got,exp, name="n") %>% arrange(desc(n)) %>% head(20)
)
}
# ---------------- CHECK 3: expansión por COLUMNAS ----------------
# Regla: r ∈ base, c ∈ {5,8,37,39,45} ⇒ se reparte por hijos de c (vector)
#       Debe haber EXACTAMENTE |children(c)| filas con out_sec_wi ∈ children(c)
check_3_col_expansion <- function(wu){
exp_col <- map_dfr(names(special_children), function(pc){
kids <- special_children[[pc]]
wu %>% filter(out_sec_uz == as.integer(pc), in_sec_uz %in% base_set) %>%
mutate(miss = !(out_sec_wi %in% kids)) %>%
group_by(in_cou,out_cou,in_sec_uz,out_sec_uz) %>%
summarise(
n_rows = n(),
expected = length(kids),
n_wrong = sum(miss),
has_all = n_rows == expected && n_wrong==0,
sum_prod = sum(prod, na.rm=TRUE),
.groups="drop"
) %>% mutate(children = paste(kids, collapse=","))
})
list(
resumen = exp_col %>% summarise(n=n(), n_all_ok = sum(has_all), share_ok = n_all_ok/max(n,1)),
peores  = exp_col %>% filter(!has_all) %>% arrange(desc(n_wrong)) %>% head(20)
)
}
# ---------------- CHECK 4: expansión por FILAS -------------------
# Regla: r ∈ {5,8,37,39,45}, c ∈ base ⇒ se reparte por hijos de r (vector)
check_4_row_expansion <- function(wu){
exp_row <- map_dfr(names(special_children), function(pr){
kids <- special_children[[pr]]
wu %>% filter(in_sec_uz == as.integer(pr), out_sec_uz %in% base_set) %>%
mutate(miss = !(in_sec_wi %in% kids)) %>%
group_by(in_cou,out_cou,in_sec_uz,out_sec_uz) %>%
summarise(
n_rows = n(),
expected = length(kids),
n_wrong = sum(miss),
has_all = n_rows == expected && n_wrong==0,
sum_prod = sum(prod, na.rm=TRUE),
.groups="drop"
) %>% mutate(children = paste(kids, collapse=","))
})
list(
resumen = exp_row %>% summarise(n=n(), n_all_ok = sum(has_all), share_ok = n_all_ok/max(n,1)),
peores  = exp_row %>% filter(!has_all) %>% arrange(desc(n_wrong)) %>% head(20)
)
}
# ---------------- CHECK 5: bloques especial×especial --------------
# Regla: r ∈ specials, c ∈ specials ⇒ debe existir la malla hijos(r) × hijos(c)
check_5_block_specials <- function(wu){
sp_ids <- as.integer(names(special_children))
combos <- expand_grid(pr = sp_ids, pc = sp_ids)
out <- pmap_dfr(combos, function(pr, pc){
RR <- special_children[[as.character(pr)]]
CC <- special_children[[as.character(pc)]]
wu %>% filter(in_sec_uz==pr, out_sec_uz==pc) %>%
mutate(ok_r = in_sec_wi %in% RR, ok_c = out_sec_wi %in% CC) %>%
group_by(in_cou,out_cou,in_sec_uz,out_sec_uz) %>%
summarise(
n_rows = n(), expected = length(RR)*length(CC),
n_miss_r = sum(!ok_r), n_miss_c = sum(!ok_c),
has_all = (n_rows==expected && n_miss_r==0 && n_miss_c==0),
sum_prod = sum(prod, na.rm=TRUE),
.groups="drop"
) %>% mutate(pair = paste0(pr,"×",pc), need_grid = paste0("(",paste(RR,collapse=","),")×(",paste(CC,collapse=","),")"))
})
list(
resumen = out %>% summarise(n=n(), n_all_ok=sum(has_all), share_ok=n_all_ok/max(n,1)),
peores  = out %>% filter(!has_all) %>% arrange(desc(expected - n_rows), desc(n_miss_r+n_miss_c)) %>% head(20)
)
}
# ---------------- CHECK 6: no fugas a hijos equivocados -----------
# Regla: si out_sec_uz es especial ⇒ out_sec_wi debe pertenecer a children(out_sec_uz) (y análogo por filas)
check_6_no_leaks <- function(wu){
# Columnas
leak_col <- map_dfr(names(special_children), function(pc){
kids <- special_children[[pc]]
wu %>% filter(out_sec_uz == as.integer(pc)) %>%
mutate(leak = !(out_sec_wi %in% kids)) %>%
summarise(group=paste0("c:",pc), leaks = sum(leak), n=n(), share_leak=leaks/max(n,1))
})
# Filas
leak_row <- map_dfr(names(special_children), function(pr){
kids <- special_children[[pr]]
wu %>% filter(in_sec_uz == as.integer(pr)) %>%
mutate(leak = !(in_sec_wi %in% kids)) %>%
summarise(group=paste0("r:",pr), leaks = sum(leak), n=n(), share_leak=leaks/max(n,1))
})
bind_rows(leak_col, leak_row) %>% arrange(desc(leaks))
}
# ---------------- (Opcional) contraste con matriz ancha -------------
# Vuelve a calcular la matriz ancha y contrástala con wiliam_wide_c si la tienes
check_7_contrast_wide <- function(wu, wide_mat = NULL){
recalc <- wu %>%
mutate(
insecou  = paste(in_cou, in_sec_wi, sep="-"),
outsecou = paste(out_cou, out_sec_wi, sep="-")
) %>%
select(insecou,outsecou,prod) %>%
group_by(insecou,outsecou) %>% summarise(prod = sum(prod, na.rm=TRUE), .groups="drop") %>%
pivot_wider(names_from=outsecou, values_from=prod, values_fill=0)
if (is.null(wide_mat)) return(list(recalc=recalc, diff_summary=NULL))
# Alinea columnas y filas por nombre
common_rows <- intersect(recalc$insecou, wide_mat[[1]] %||% character())
# Si wide_mat es un data.frame con primera columna = fila, ajústalo aquí si quieres.
message("[check_7] Si necesitas contraste exacto con wiliam_wide_c,")
message("          pásame la estructura concreta de esa tabla (cómo vienen las filas).")
list(recalc=recalc, diff_summary=NULL)
}
# ---------------- RUN ALL ----------------
run_all_checks <- function(wiliam_unizar, wiliam_wide_c=NULL){
wu <- prep_wu(wiliam_unizar)
out <- list()
out$health <- check_0_health(wu)
out$base_base <- check_1_base_base(wu)
out$remaps <- check_2_remaps(wu)
out$col_exp <- check_3_col_expansion(wu)
out$row_exp <- check_4_row_expansion(wu)
out$block_sp <- check_5_block_specials(wu)
out$no_leaks <- check_6_no_leaks(wu)
out$contrast <- check_7_contrast_wide(wu, wiliam_wide_c)
out
}
# ================= EJEMPLO DE USO =================
# asumiendo que ya tienes cargado en memoria:
#   load("./DataRafa/wiliam_unizar.RData")
#   load("./DataRafa/wiliam_wide_c.RData")   # opcional
res_chk <- run_all_checks(wiliam_unizar, wiliam_wide_c)
res_chk$health
res_chk$base_base$summary; res_chk$base_base$top_viol
res_chk$remaps$in_summary;  res_chk$remaps$out_summary
res_chk$col_exp$resumen;    res_chk$col_exp$peores
res_chk$row_exp$resumen;    res_chk$row_exp$peores
res_chk$block_sp$resumen;   res_chk$block_sp$peores
res_chk$no_leaks
